# 第四周

## 数学思维

~~~cpp
// 在一个有序序列（升序序列）求第一个大于x的元素的位置
int upper_bound(int a[],int left ,int right,int x)
{
    int mid;
    while (left<right){
        mid=(left+right)/2;
        if(a[mid]>x){
            right=mid;
        }
        else{
            left=mid+1;
        }
    }
    return left;
}
/*我之前在算法导论习题2-3.6中就遇到了这个，但是当时一直没有办法将第一个大于x的元素的位置找出来，因为我当时的想法是怎么去求出这个元素的位置，甚至我也想了先找出x，然后再去往后找，但是这时我就会遇到，如果这个序列中没有x怎么办，如果有x，而且有很多个怎么办。但是始终没有领会二分查找的精髓——————（夹（两边夹住）  逼（逼近要求的值））
在这个例题中，如果使用上面的夹，逼思想便可以解出这个题的解
1、二分的初始区间应当能覆盖到所有可能返回的结果。首先二分下界是0是显然的，但是二分上界为什么是n而不是n-1呢？这是因为考虑到欲查询的元素可能比序列中的所有元素都要大，此时应当返回n;
2、如果a[mid]>x，说明第一个大于x的元素的位置一定在mid处或者mid的左侧，应该往左子区间[left,mid]继续查询。
3、 如果a[mid]<=x，说明第一个大于x的元素的位置一定是在mid的右侧，应往右子区间[mid+1,right]
4、设第一个小于x的元素为y,当a[left]<=y<=a[right]时，所以当0=<a[left]=a[right]<=n-1时，由夹逼定理知，y=a[left]=a[right];当y<a[left]时，a[left]=a[right]=0;当y>a[right]时，a[left]=a[right]=n;

~~~

## 位与字节

位（bit）:二进制数的一位，也称位比特，是==计算机存储数据的最小单位（bit）==.

字节（byte）:==是存储数据的基本单位==，一个字节通常是由8位二进制数的组成的。

一个英文单词占一位，一个汉字占两位。

### 位运算操作符

| 运算符 | 含义   |
| ------ | ------ |
| “&”    | 按位与 |
| “      | ”      |
| "~"    | 取反   |
| "^"    | 异或   |
| "<<"   | 左移   |
| ">>"   | 右移   |



### 按位异或运算符 “^”

按位异或运算符时是双目运算符。功能是使参与运算的两数个对应的二进位相异或，当对应的两个二进位数相异时结果为1，否则结果为0.

|  a   |  b   | a^b  |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  0   |  1   |  1   |
|  1   |  1   |  0   |
|  1   |  0   |  1   |

两个特例 ：一个操作数和位数相同的0和1做按位异或运算

| 操作数1 | 0111 | 0110 |
| ------- | ---- | ---- |
| 操作数2 | 0000 | 0000 |
| 结果    | 0111 | 0110 |

| 操作数1 | 0111 | 0110 |
| ------- | ---- | ---- |
| 操作数2 | 1111 | 1111 |
| 结果    | 1000 | 1001 |

结合上面的内容，可以将一个二进位数中的n位进行按位取反。

如：将后四位按位取反

| 操作数1 | 01110110 |
| ------- | -------- |
| 操作数2 | 00001111 |
| 结果    | 01111001 |

### 左移运算符“<<”与右移运算符">>"

左移运算符和右移运算符都是双目运算符。

左移运算符的功能是把"<<"左边的操作数的个二进位全部左移若干位，由"<<"右边的操作数来指定移动的位数，高位丢弃，低位补0；

实际上左移一位相当于该数乘以二，左移两位相当于将该数乘以四。但是这种情况只限于溢出位不含1的情况，如果是将十进制数64左移两位则移位后的结果将为0（01000000---->00000000）,因为64在左移两位时将1移除了（注意这里的64时假设以一个字节即8位存储的）。

~~~cpp 
int x=15;
x=x<<2;
cout<<x;
//x=60
~~~

右移运算符的功能是，把">>"左边的运算符的各二进位全部右移若干位，">>"右边的数指定移动的位数。在进行有意是对于有符号数需要注意符号位问题，当为正数时，最高位补0，而为负数时，最高位是补0还是补1取决于编译系统的规定。移入0的称为"逻辑右移"，移入1的称为“算术右移”

~~~cpp
int a=-12;
a=a>>2;
cout<<a;
//a=-3;
~~~





###  按位与运算符 "&"

运算法则：

| a    | b    | a&b  |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 0    |
| 1    | 0    | 0    |
| 1    | 1    | 1    |

取一个二进制数a的后五位：

| 操作数与按位与运算 | 实例             |
| ------------------ | ---------------- |
| a                  | 011==10110==     |
| b                  | **000==11111==** |
| a&b                | 000==10110==     |



if(b%2==1) 可以使用if(b&1)代替，这是因为b&1进行位与操作，判断b的末位是否为1,因此当b为奇数时b&1返回1，if条件成立。这样写执行速度会更快。

### 按位或运算符"|"

按位或运算符是双目运算符;

运算法则;

| a    | b    | a\|b |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 1    |

取8位的二进制数的后五位都变为1：

| 操作数与按位或运算符 | 实例         |
| -------------------- | ------------ |
| a                    | 011**10110** |
| b                    | 000**11111** |
| a\|b                 | 011**11111** |

### 按位取反运算符"~"

按位取反运算符为单目运算符。

64

01000000

~64

10111111

### 位运算复合操作符

位运算复合赋值运算符是由位运算符与赋值运算符组成的，其中包括: &=    |=    ^=    <<=    >>=等

a&=b,相当于a=a&b;

位运算符的优先级与结合性：

位运算的优先级从高到低的顺序为：“ ~ ”   “>> , <<"  "&"   "^"   "|"

位逻辑运算符的优先级高于逻辑运算符，低于关系运算符，其结合方向是自右向左的。

位移位运算符的优先级低于算术运算符，高于关系运算符，其结合方向是自左向右的。

位复合运算符的优先级与算术复合赋值运算符相同。 

==注意长度不同的数据进行位运算==：这时，系统会将不同的两个数按照右侧对齐，左侧填满的方法，如果较短的数为正数，则会在较短的数据左侧补满 

## 快速幂（二分法）

快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。让我们先来看一个简单的例子：

3^10=3*3*3*3*3*3*3*3*3*3

//尽量想办法把指数变小来，这里的指数为10

$3^{10}=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)$

$3^{10}=(3*3)^5$

$3^{10}=9^5$

//此时指数由10缩减一半变成了5，而底数变成了原来的平方，求$3^{10}$原本需要执行10次循环操作，求$9^{5}$ 却只需要执行5次循环操作，但是$3^{10}$却等于$9^{5}$,我们==用一次（底数做平方操作）的操作减少了原本一半的循环量==，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。

//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5

9^5=（9^4）*（9^1）

//此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作

9^5=（81^2）*(9^1)

//把指数缩小一半，底数执行平方操作

9^5=（6561^1）*(9^1)

//此时，我们发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1，这个6561^1我们先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。

9^5=（6561^0）*(9^1)*(6561^1)=1*(9^1)*(6561^1)=(9^1)*(6561^1)=9*6561=59049

我们能够发现，最后的结果是9*6561，而9是怎么产生的？是不是当指数为奇数5时，此时底数为9。那6561又是怎么产生的呢？是不是当指数为奇数1时，此时的底数为6561。所以我们能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。
原文链接：https://blog.csdn.net/qq_19782019/article/details/85621386

## 随机数

rand()与srand（）

首先，rand()产生的是一个[0,RAND_MAX]范围内的伪随机数，然后可以用这个随机数除以RAND_MAX，这样就会得到一个[0,1]的浮点数。

~~~cpp
int a=rand()/RAND_MAX;
//如果想得到[a,b]范围内的随机数
int b=1.0*rand()/RAND_MAX*(b-a)+a;
~~~

因为rand()得到的是伪随机数，所以为了改变这种现状我们使用srand();

~~~cpp
#include <iostream>
#include <time.h>
int main()
{
    srand((unsigned) time(NULL));
    int a=rand();
    std::cout<<a;
    return 0;
}
//如果没有使用srand(),那么程序每次执行的时候都会是一样的。
~~~

