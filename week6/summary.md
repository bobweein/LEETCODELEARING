# 第六周
本周因为考试复习学习的内容就会有少。

##  随机算法

1. 有时当我们无法得知输入分布的信息，因此阻碍了平均情况的分析，这时候我们就可以使用随机算法。

2. 很多随机算法通过对给定的输入变换排列以使输入随机化。

3. 一般的做法是构造一个均匀随机序列，该过程可以等可能的产生数字1~n的每一种排列。

   **注意** 证明对每个元素，他排在某一个特定位置的概率1/n，但是这个弱条件实际上并不充分。《算法导论》课后习题5.3-4给出了反例。

   具体地说就是，对于数组$A[i],i=1,2,3,....,n $ 中的任何一个元素出现在特定位置$j，j=1,2,....,n$ 上的可能性是1/n，但是这是一个弱条件，而应该是这样，因为对于任意的n个数，可以产生n!中排列，根据定义知，需要保证构造序列的函数能产生n!种排列，且这些排列中每一个具体的n排列的概率为1/n!,即产生的n!中序列都是等可能的。根据反例知，虽然数组中的任何一个元素出现在某一特定位置的是等可能的，概率为1/n，但是这个构造序列的函数，只能产生n种n排列，其他n!-n种n排列的概率为0；

4. 结合概率分析和指示器随机变量的方法求解期望时间复杂度。例子生日悖论，球与箱子，特征序列（==这一部分中有没搞懂的地方==），以及在线雇佣问题。

##  线性时间排序

### 计数排序

1. 计数排序假设n个输入元素中的每一个都是在0~k区间内的一个整数，其中k为某个整数。

2. 计数排序的基本思想是，对每一个输入的元素x，确定小于x的元素个数。

3. 计数排序的一个重要的性质就是他是稳定的：具有相同值的两个元素在输出数组中的相对次序与他们在输入数组中的相对次序相同。也就是说，对两个相同的书来说，在输入数组中先出现的数，在输出数组中也位于前面。

4. 在《算法导论》中，这里是假设n个输入元素中的每一个元素都是在0~n区间内，当输入序列为$\{1 ，2 ，555 ，999 ，10000\}$ 时，这样就会导致提供临时存储空间的数组过大。

### 基数排序

1. 基数排序是先按最低有效位进行排序来解决n个数的排序问题。
2. 为了确保基数排序的正确性，一位数排序算法必须是稳定的，这就是为什么基数排序为什么会使用计数排序作为他的子程序。具体见使用数学归纳法证明基数排序的正确性。
3. 自己使用数学归纳法证明了基数排序的正确性。可以整理一下然后发一篇博客。

### 桶排序

1. 在《算法导论》中，桶排序假设输入数据服从均匀分布，平均情况下他的时间复杂度为O(n).
2. 桶排序算法结合比较插入算法对每一个桶中的元素进行排序。
3. 即使输入数据不服从均匀分布，桶排序也仍然可以线性时间完成，只要输入数据满足下列性质：所有桶的大小的平方和与总的元素数呈线性关系，那么通过概率分析可以知道；桶排序依然能够在线性时间内完成。

